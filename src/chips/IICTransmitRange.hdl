CHIP IICTransmitRange {
  IN reset, startAt[16], stopAt[16], sendStart, sendStop;
  OUT address[16], sda, scl;
  PARTS:
  // Should Register be set this clock cycle?
  Or8Way(
    in[0]=startDone,
    in[1]=byteDone,
    in[2]=ackDone,
    in[3]=stopDone,
    out=updateRegister
  );
  // What value should the register have?
  Register(
    in[0]=nextIdleState,
    in[1]=nextStartState,
    in[2]=nextByte0State,
    in[3]=nextAck0State,
    in[4]=nextByte1State,
    in[5]=nextAck1State,
    in[6]=nextStopState,
    load=updateRegister,
    out[0]=idleState,
    out[1]=startState,
    out[2]=byte0State,
    out[3]=ack0State,
    out[4]=byte1State,
    out[5]=ack1State,
    out[6]=stopState
  );
  // we want to target a transmission speed of 100 kbit/s
  // 100kbit/s is 12500 byte/s
  // the clock speed is 25MHz
  // (25,000,000 clock cycles / 1s) * (1s / 12500 bytes) = 2000 cycles / byte
  // Each byte has 8 bits and each bit as 4 iic phases so 
  // 2000 cycles / byte * 32 iic cycles / byte
  // = 62.5 which we'll round to 62
  // 62 = 0011 1110
  // The ClockDivider "max" value is actually 1/2 the period so we want
  // 31 = 0001 1111
  ClockDivider(
    reset=blipReset,
    max[0]=false,
    max[1]=true,
    max[2]=true,
    max[3]=true,
    max[4]=true,
    max[5]=true,
    out=clock0
  );
  QuarterClock(
    clockIn=clock0,
    reset=blipReset,
    quarter=bitClock
  );
  EigthClock(
    clockIn=bitClock,
    reset=blipReset,
    quarter=halfbyteClock,
    eigth=byteClock
  );
  HalfClock(
    clockIn=byteClock,
    reset=blipReset,
    clockOut=wordClock
  );

  // State for start and stop conditions.
  Equal(a=pc, b=startAt, out=atStart);
  Equal(a=pc, b=stopAt, out=atStop);
  And(a=atStart, b=sendStart, out=sendingStart);
  And(a=atStop,  b=sendStop,  out=sendingStop);

  // When to increment the address counter
  Blop(in=byteClock, out=incClock);
  Not(in=atStop, out=countUp);
  And(a=countUp, b=incClock, out=inc);

  // Trigger to start sending message
  Blip(in=reset, out=blipReset);

  // The address counter
  PC(inc=inc, in=startAt, load=blipReset, out=pc);

  // The final idle state
  Blip(in=halfbyteClock, out=finalClock);
  Or(a=blipReset, b=finalClock, out=loadFinal);
  Mux(sel=blipReset, a=sendingStop, b=false, out=done0);
  FastBit(in=done0, load=loadFinal, out=done);

  // Select the byte to send
  ROM32KLessAnnoying(address=pc, out[0..7]=byte2, out[8..15]=byte1);
  Mux16(a[0..7]=byte1, b[0..7]=byte2, sel=byte1State, out[0..7]=byte);

  // Generate SDA and SCL signals
  Blip(in=startState, out=beginStart);
  IICStart(
    clock0=clock0,
    reset=beginStart,
    sda=sdaStart,
    scl=sclStart,
    done=startDone
  );
  Or(a=byte0State, b=byte1State, out=anyByteState);
  Blip(in=anyByteState, out=beginByte);
  IICByte(
    clock0=clock0,
    reset=beginByte,
    in=byte,
    sda=sdaByte,
    scl=sclByte,
    done=byteDone
  );
  Or(a=ack0State, b=ack1State, out=anyAckState);
  Blip(in=anyAckState, out=beginAck);
  IICAckReceive(
    clock0=clock0,
    reset=beginAck,
    sda=sdaAck,
    scl=sclAck,
    done=ackDone
  );
  Blip(in=doneState, out=beginDone);
  IICStop(
    clock0=clock0,
    reset=beginDone,
    sda=sdaStop,
    scl=sclStop,
    done=stopDone
  );

  // Determine which signal gets put on the actual sda and scl lines
  And(a=sdaStart, b=startState, out=sdaStartCut);
  And(a=sclStart, b=startState, out=sclStartCut);

  And(a=sdaByte, b=anyByteState, out=sdaByteCut);
  And(a=sclByte, b=anyByteState, out=sclByteCut);

  And(a=sdaAck, b=anyAckState, out=sdaAckCut);
  And(a=sclAck, b=anyAckState, out=sclAckCut);

  And(a=sdaStop, b=stopState, out=sdaStopCut);
  And(a=sclStop, b=stopState, out=sclStopCut);

  And(a=true, b=idleState, out=sdaIdleCut);
  And(a=true, b=idleState, out=sclIdleCut);

  Or8Way(
    in[0]=sdaStartCut,
    in[1]=sdaByteCut,
    in[2]=sdaAckCut,
    in[3]=sdaStopCut,
    in[4]=sdaIdleCut,
    out=sda
  );

  Or8Way(
    in[0]=sclStartCut,
    in[1]=sclByteCut,
    in[2]=sclAckCut,
    in[3]=sclStopCut,
    in[4]=sclIdleCut,
    out=scl
  );

  // Update state machine.
  // idleState =
  Copy(in=stopState, out=nextIdleState);

  // startState =
  And(a=reset, b=idleState, out=nextStartState);

  // byte0State =
  Not(in=atStop, out=natStop);
  And(a=natStop, b=ack1State, out=moreWords);
  Or(a=startState, b=moreWords, out=nextByte0State);

  // ack0State =
  Copy(in=byte0State, out=nextAck0State);

  // byte1State =
  Not(in=atStop, out=natStop);
  And(a=natStop, b=ack0State, out=nextByte1State);

  // ack1State =
  Copy(in=byte1State, out=nextAck1State);

  // stopState =
  Or(a=ack0State, b=ack1State, out=anyAckState);
  And(a=atStop, b=anyAckState, out=nextStopState);

  // For debugging fun
  Copy(in=pc, out=address);
}
